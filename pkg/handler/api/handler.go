package api

import (
	"encoding/json"
	"github.com/rs/zerolog/log"
	"net/http"
	"oauth2-pentester/pkg/derror"
	"oauth2-pentester/pkg/logger"
	srvthreat "oauth2-pentester/pkg/threat/server"
	cltthreat "oauth2-pentester/pkg/threat/client"
)

const (
	failStatus   = "fail"
	passedStatus = "passed"
)

type report struct {
	Threat string
	Status string
}

type ServerAnalyzeBody struct {
	AuthURL             string `json:"auth_url"`
	Username            string `json:"username"`
	Password            string `json:"password"`
	TokenURL            string `json:"token_url"`
	ClientID            string `json:"client_id"`
	ClientSecret        string `json:"client_secret"`
	Scope 				string `json:"scope"`
	MalwareClientID     string `json:"malware_client_id"`
	MalwareClientSecret string `json:"malware_client_secret"`
	ElementEmailName    string `json:"element_email_name"`
	ElementPassName     string `json:"element_pass_name"`
	ElementEnterID      string `json:"element_enter_id"`
}

type ClientAnalyzeBody struct {
	AuthURL string `json:"auth_url"`
	CallbackURL string `json:"callback_url"`
}

func ServerAnalyze(w http.ResponseWriter, r *http.Request) {
	srvAnalyzeBody := new(ServerAnalyzeBody)
	if err := json.NewDecoder(r.Body).Decode(srvAnalyzeBody); err != nil {
		log.Error().Err(err).Msg(logger.FailDecodeJSON)
		writeResponse(w, derror.SerilizeError(derror.NewAnalyze()), http.StatusUnprocessableEntity)
		return
	}

	threats := srvthreat.GetThreats(srvAnalyzeBody.AuthURL,
		srvAnalyzeBody.Username,
		srvAnalyzeBody.Password,
		srvAnalyzeBody.TokenURL,
		srvAnalyzeBody.ClientID,
		srvAnalyzeBody.ClientSecret,
		srvAnalyzeBody.Scope,
		srvAnalyzeBody.MalwareClientID,
		srvAnalyzeBody.MalwareClientSecret,
		srvAnalyzeBody.ElementEmailName,
		srvAnalyzeBody.ElementPassName,
		srvAnalyzeBody.ElementEnterID)

	reports := make([]report, len(threats))
	for i, threat := range threats {
		res, err := threat.Analyze()
		if err != nil {
			writeResponse(w, derror.SerilizeError(err), http.StatusUnprocessableEntity)
			return
		}

		status := failStatus
		if res {
			status = passedStatus
		}
		reports[i] = report{
			Threat: threat.String(),
			Status: status,
		}
	}

	res, _ := json.Marshal(reports)
	writeResponse(w, res, http.StatusOK)
}

func ClientAnalyze(w http.ResponseWriter, r *http.Request) {
	cltAnalyzeBody := new(ClientAnalyzeBody)
	if err := json.NewDecoder(r.Body).Decode(cltAnalyzeBody); err != nil {
		log.Error().Err(err).Msg(logger.FailDecodeJSON)
		writeResponse(w, derror.SerilizeError(derror.NewAnalyze()), http.StatusUnprocessableEntity)
		return
	}

	threats := cltthreat.GetThreats(cltAnalyzeBody.AuthURL, cltAnalyzeBody.CallbackURL)

	reports := make([]report, len(threats))
	for i, threat := range threats {
		res, err := threat.Analyze()
		if err != nil {
			writeResponse(w, derror.SerilizeError(err), http.StatusUnprocessableEntity)
			return
		}

		status := failStatus
		if res {
			status = passedStatus
		}
		reports[i] = report{
			Threat: threat.String(),
			Status: status,
		}
	}

	res, _ := json.Marshal(reports)
	writeResponse(w, res, http.StatusOK)
}

func writeResponse(w http.ResponseWriter, body []byte, code int) {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(code)
	w.Write(body)
}
