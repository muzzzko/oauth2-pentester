package threat

import (
	"context"
	"fmt"
	"github.com/rs/zerolog/log"
	"net/http"
	"oauth2-pentester/pkg/derror"
	"oauth2-pentester/pkg/logger"
	"oauth2-pentester/pkg/selenium"
)

type Response307 struct {
	authURL             string
	username            string
	password            string
	clientID            string
	elementEmailName    string
	elementPassName     string
	elementEnterID      string

	client *http.Client
}

func NewResponse307(
	authURL,
	username,
	password,
	clientID,
	elementEmailName,
	elementPassName,
	elementEnterID string,
	client *http.Client) *Response307 {

	threat := new(Response307)
	threat.authURL = authURL
	threat.username = username
	threat.password = password
	threat.clientID = clientID
	threat.elementEmailName = elementEmailName
	threat.elementPassName = elementPassName
	threat.elementEnterID = elementEnterID
	threat.client = client

	return threat
}

func (t *Response307) Analyze() (bool, derror.Error) {
	out := make(chan string, 1)
	ctx, cancel := context.WithCancel(context.Background())
	go func() {
		r := http.NewServeMux()
		r.HandleFunc(callbackPath, func(w http.ResponseWriter, r *http.Request) {
			out <- r.Method
		})
		srv := new(http.Server)
		srv.Addr = callbackServerAddr
		srv.Handler = r

		go func() {
			if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
				log.Error().Err(err).Msg(logger.FailListenServer)
			}
			log.Info().Msg(fmt.Sprintf("Stop server on address %s", srv.Addr))
		}()

		<-ctx.Done()
		srv.Shutdown(ctx)
	}()

	if err := selenium.Auth(t.authURL,
		t.username,
		t.password,
		t.clientID,
		redirectURI,
		t.elementEmailName,
		t.elementPassName,
		t.elementEnterID); err != nil {
		return false, err
	}

	res := <-out
	cancel()

	if res != http.MethodGet {
		return false, nil
	}

	return true, nil
}

func (t *Response307) String() string {
	return "Ответ сервера авторизации с кодом 307"
}

