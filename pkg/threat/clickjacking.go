package threat

import (
	"github.com/rs/zerolog/log"
	"net/http"
	"net/url"
	"oauth2-pentester/pkg/derror"
	"oauth2-pentester/pkg/logger"
	"strings"
)

const (
	xFrameOptionsHeader = "X-Frame-Options"
	denyValue = "deny"
	sameoriginValue = "sameorigin"
)

type ClickJacking struct {
	authURL string
	clientID string

	client *http.Client
}

func NewClickJacking(authURL, clientID string, client *http.Client) *ClickJacking {
	threat := new(ClickJacking)
	threat.authURL = authURL
	threat.clientID = clientID
	threat.client = client

	return threat
}

func (t *ClickJacking) Analyze() (bool, derror.Error) {
	URL, _ := url.Parse(t.authURL)
	q := URL.Query()
	q.Set("client_id", t.clientID)
	q.Set("redirect_uri", redirectURI)
	q.Set("response_type", "code")
	URL.RawQuery = q.Encode()

	r, err := http.NewRequest(http.MethodGet, URL.String(), http.NoBody)
	if err != nil {
		log.Error().Err(err).Msg(logger.FailCreateRequest)
		return false, derror.NewAnalyze()
	}
	resp, err := t.client.Do(r)
	if resp != nil {
		resp.Body.Close()
	}
	if err != nil {
		log.Error().Err(err).Msg(logger.FailDoRequest)
		return false, derror.NewAnalyze()
	}

	value := strings.ToLower(resp.Header.Get(xFrameOptionsHeader))
	if value != denyValue && value != sameoriginValue {
		return false, nil
	}

	return true, nil
}

func (t *ClickJacking) String() string {
	return "Авторизация пользователей в фоновом режиме и последующая кража данных"
}
