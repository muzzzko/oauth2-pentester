package threat

import (
	"context"
	"encoding/json"
	"fmt"
	"github.com/gorilla/mux"
	"github.com/rs/zerolog/log"
	"io/ioutil"
	"net/http"
	"oauth2-pentester/pkg/derror"
	"oauth2-pentester/pkg/logger"
)

type creds struct {
	RefreshToken string `json:"refresh_token"`
	AccessToken  string `json:"access_token"`
	Code 		 string `json:"code"`
}

func requestTokenPair(
	grantParamName,
	grant,
	grantType,
	tokenURL,
	clientID,
	clientSecret,
	scope,
	redirectURI string) (string, string, derror.Error) {

	req, err := http.NewRequest(http.MethodPost, tokenURL, http.NoBody)
	if err != nil {
		log.Error().Err(err).Msg(logger.FailCreateRequest)
		return "", "", derror.NewAnalyze()
	}

	q := req.URL.Query()
	q.Set(grantParamName, grant)
	q.Set("client_id", clientID)
	if clientSecret != "" {
		q.Set("client_secret", clientSecret)
	}
	if scope != "" {
		q.Set("scope", scope)
	}
	q.Set("redirect_uri", redirectURI)
	q.Set("grant_type", grantType)
	req.URL.RawQuery = q.Encode()

	client := http.Client{}
	resp, err := client.Do(req)
	if resp != nil {
		defer resp.Body.Close()
	}
	if err != nil {
		log.Error().Err(err).Msg(logger.FailDoRequest)
		return "", "", derror.NewAnalyze()
	}

	tokenPair := struct {
		RefreshToken string `json:"refresh_token"`
		AccessToken  string `json:"access_token"`
	}{}
	body, _ := ioutil.ReadAll(resp.Body)
	if err := json.Unmarshal(body, &tokenPair); err != nil {
		log.Error().Err(err).Msg(logger.FailDecodeJSON)
		return "", "", derror.NewAnalyze()
	}
	log.Debug().Str(logger.BodyField, string(body)).Msg(logger.FailGetTokenPair)

	return tokenPair.AccessToken, tokenPair.RefreshToken, nil
}

func getCreds(
	ctx context.Context,
	tokenURL,
	clientID,
	clientSecret,
	scope string,
	out chan<- interface{}) {

	r := mux.NewRouter()
	r.HandleFunc(callbackPath, func(w http.ResponseWriter, r *http.Request) {
		vcreds := new(creds)
		vcreds.Code = r.URL.Query().Get("code")

		var err error
		vcreds.AccessToken, vcreds.RefreshToken, err = requestTokenPair(codeParam,
			vcreds.Code,
			codeGrantType,
			tokenURL,
			clientID,
			clientSecret,
			scope,
			redirectURI,
		)
		if err != nil {
			out <- err
			return
		}

		out <- vcreds
	})

	srv := new(http.Server)
	srv.Addr = callbackServerAddr
	srv.Handler = r

	go func() {
		if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
			log.Error().Err(err).Msg(logger.FailListenServer)
		}
		log.Info().Msg(fmt.Sprintf("Stop server on address %s", srv.Addr))
	}()

	<-ctx.Done()
	srv.Shutdown(ctx)
}

