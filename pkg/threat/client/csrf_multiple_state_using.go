package threat

import (
	"context"
	"github.com/rs/zerolog/log"
	"net/http"
	"net/url"
	"oauth2-pentester/pkg/derror"
	"oauth2-pentester/pkg/logger"
	"sync"
)

type CSRFMultipleStateUsing struct {
	baseThreat
}

func NewCSRFMultipleStateUsing(authURL string, client *http.Client) *CSRFMultipleStateUsing {
	threat := new(CSRFMultipleStateUsing)
	threat.authURL = authURL
	threat.client = client

	return threat
}

func (t *CSRFMultipleStateUsing) Analyze() (bool, derror.Error) {
	authURL, derr := t.getAuthURL()
	if derr != nil {
		return false, derr
	}

	redirectURI, err := url.Parse(authURL.Query().Get("redirect_uri"))
	if err != nil {
		log.Error().Err(err).Msg(logger.FailParseURI)
		return false, derror.NewAnalyze()
	}
	q := redirectURI.Query()
	q.Add(codeParam, "code")
	q.Add(stateParam, authURL.Query().Get(stateParam))
	redirectURI.RawQuery = q.Encode()

	ctx, cancel := context.WithCancel(context.Background())
	out := make(chan interface{}, 5)
	wg := new(sync.WaitGroup)
	wg.Add(1)
	handleTokenRequest(ctx, wg, out)

	var count int
	for range make([]int, 2) {
		resp, derr := t.makeGetRequest(redirectURI.String())
		if resp != nil {
			resp.Body.Close()
		}
		if derr != nil {
			cancel()
			return false, derr
		}
	}

	cancel()
	wg.Wait()
	close(out)
	for res := range out {
		if err, ok := res.(derror.Error); ok {
			return false, err
		}

		if _, ok := res.(bool); !ok {
			log.Error().Interface(logger.BoolField, res).Msg(logger.FailConvertBool)
			return false, derror.NewAnalyze()
		} else {
			count++
		}
	}

	if count != 1 {
		return false, nil
	}

	return true, nil
}

func (t *CSRFMultipleStateUsing) String() string {
	return "CSRF. Клиент допускает полчение токена несолько раз с одним и тем же state"
}
