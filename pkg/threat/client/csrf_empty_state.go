package threat

import (
	"context"
	"github.com/rs/zerolog/log"
	"net/http"
	"net/url"
	"oauth2-pentester/pkg/derror"
	"oauth2-pentester/pkg/logger"
	"sync"
)

type CSRFEmptyState struct {
	baseThreat
}

func NewCSRFEmptyState(authURL string, client *http.Client) *CSRFEmptyState {
	threat := new(CSRFEmptyState)
	threat.authURL = authURL
	threat.client = client

	return threat
}

func (t *CSRFEmptyState) Analyze() (bool, derror.Error) {
	authURL, derr := t.getAuthURL()
	if derr != nil {
		return false, derr
	}

	redirectURI, err := url.Parse(authURL.Query().Get("redirect_uri"))
	if err != nil {
		log.Error().Err(err).Msg(logger.FailParseURI)
		return false, derror.NewAnalyze()
	}
	q := redirectURI.Query()
	q.Add(codeParam, "code")
	redirectURI.RawQuery = q.Encode()

	ctx, cancel := context.WithCancel(context.Background())
	out := make(chan interface{}, 5)
	wg := new(sync.WaitGroup)
	wg.Add(1)
	handleTokenRequest(ctx, wg, out)

	resp, derr := t.makeGetRequest(redirectURI.String())
	if resp != nil {
		resp.Body.Close()
	}
	if derr != nil {
		cancel()
		return false, derr
	}

	cancel()
	wg.Wait()
	close(out)
	for res := range out {
		if err, ok := res.(derror.Error); ok {
			return false, err
		}

		if _, ok := res.(bool); !ok {
			log.Error().Interface(logger.BoolField, res).Msg(logger.FailConvertBool)
			return false, derror.NewAnalyze()
		} else {
			return true, nil
		}
	}

	return false, nil
}

func (t *CSRFEmptyState) String() string {
	return "CSRF. Клиент допускает обработку запроса после аутентификации без параметра state"
}
